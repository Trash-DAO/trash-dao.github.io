{"version":3,"sources":["app/hooks.ts","features/connectWallet/connectWalletAPI.ts","features/connectWallet/connectWalletSlice.ts","features/connectWallet/ConnectWallet.tsx","features/NftFaucet/nftFaucetAPI.ts","features/NftFaucet/nftFaucetSlice.ts","features/NftFaucet/NftFaucet.tsx","features/TrashCan/trashCanAPI.ts","features/TrashCan/trashCanSlice.ts","features/TrashCan/TrashCan.tsx","App.tsx","app/store.ts","serviceWorker.ts","index.tsx","features/NftFaucet/NftFaucet.module.css"],"names":["useAppDispatch","useDispatch","useAppSelector","useSelector","connectWallet","a","window","ethereum","send","web3","Web3","eth","net","getNetworkType","network","getAccounts","accounts","address","isWalletConnectedAsync","createAsyncThunk","Promise","resolve","isConnected","response","connectWalletAsync","hasWalletAsync","connectWalletSlice","createSlice","name","initialState","connected","loading","hasWallet","reducers","setHasWallet","state","action","payload","extraReducers","builder","addCase","pending","fulfilled","rejected","error","selectConnected","actions","selectLoading","selectAddress","selectNetwork","selectHasWallet","ConnectWallet","dispatch","target","rel","href","onClick","nftFaucetContract","nftFaucetAddress","getNftFaucetContract","Contract","nftFaucetAbi","listenForMints","callback","events","Transfer","filter","to","selectedAddress","event","console","log","tokenId","returnValues","methods","tokenURI","call","tokenUri","mint","transactionParameters","from","data","encodeABI","request","method","params","reject","once","alreadyListening","mintAsync","arg","thunkAPI","mintSuccess","nftFaucetSlice","mints","pendingTx","push","selectPendingTx","nftFaucet","selectMints","NftFaucet","length","className","styles","mintUl","map","mintLi","mintImg","src","alt","trashCanAddress","getErc721AbiContract","contractAddress","erc721Abi","listenForTransfers","safeTransferFrom","nftContract","tx","safeTransferFromAsync","transferSuccess","trashCanSlice","trashCan","TrashCan","useState","setContractAddress","setTokenId","onChange","value","trim","App","version","store","configureStore","reducer","connectWalletReducer","nftFaucetReducer","trashCanReducer","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message","module","exports"],"mappings":"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","file":"static/js/main.60eb78e1.chunk.js","sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import Web3 from \"web3\";\r\n\r\ndeclare global {\r\n  interface Window { ethereum: any; }\r\n}\r\n\r\nexport const hasWallet = () => {\r\n  return !!window.ethereum;\r\n}\r\n\r\nexport const isWalletConnected = () => {\r\n  return Promise.resolve(window.ethereum.isConnected());\r\n}\r\n\r\nexport const connectWallet = async () => {\r\n  await window.ethereum?.send('eth_requestAccounts');\r\n  const web3 = new Web3(window.ethereum);\r\n  const network = await web3.eth.net.getNetworkType();\r\n  const accounts = await web3.eth.getAccounts();\r\n  return {\r\n    address: accounts[0],\r\n    network\r\n  }\r\n}\r\n\r\nexport const addWalletListener = (callback: any) => {\r\n  window.ethereum.on(\"accountsChanged\", (accounts: any) => {\r\n    if (accounts.length > 0) {\r\n      callback(accounts[0]);\r\n    } else {\r\n      callback();\r\n    }\r\n  });\r\n}","import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport { RootState } from '../../app/store';\nimport { isWalletConnected, connectWallet, hasWallet } from './connectWalletAPI';\n\nexport interface ConnectWalletState {\n  connected: boolean;\n  loading: boolean;\n  address?: string;\n  network?: string;\n  hasWallet: boolean;\n  error?: string;\n}\n\nconst initialState: ConnectWalletState = {\n  connected: false,\n  loading: false,\n  hasWallet: false,\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\nexport const isWalletConnectedAsync = createAsyncThunk(\n  'connectWallet/isWalletConnected',\n  async () => {\n    const response = await isWalletConnected();\n    // The value we return becomes the `fulfilled` action payload\n    return response;\n  }\n);\n\nexport const connectWalletAsync = createAsyncThunk(\n  'connectWallet/connectWallet',\n  async () => {\n    const response = await connectWallet();\n    // The value we return becomes the `fulfilled` action payload\n    return response;\n  }\n);\n\nexport const hasWalletAsync = createAsyncThunk(\n  'connectWallet/hasWallet',\n  () => {\n    const response = hasWallet();\n    return response;\n  }\n);\n\n\nexport const connectWalletSlice = createSlice({\n  name: 'connectWallet',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    setHasWallet: (state, action) => {\n      state.hasWallet = action.payload;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(hasWalletAsync.pending, (state) => {\n        state.loading = true;\n      })\n      .addCase(hasWalletAsync.fulfilled, (state, action) => {\n        state.loading = false;\n        state.hasWallet = action.payload;\n      })\n      .addCase(hasWalletAsync.rejected, (state) => {\n        state.loading = false;\n        state.hasWallet = false;\n      })\n      .addCase(isWalletConnectedAsync.pending, (state) => {\n        state.loading = true;\n      })\n      .addCase(isWalletConnectedAsync.fulfilled, (state, action) => {\n        state.loading = false;\n        state.connected = action.payload;\n      })\n      .addCase(isWalletConnectedAsync.rejected, (state) => {\n        state.loading = false;\n        state.connected = false;\n        state.error = \"There was an error\";\n      })\n      .addCase(connectWalletAsync.pending, (state) => {\n        state.loading = true;\n      })\n      .addCase(connectWalletAsync.fulfilled, (state, action) => {\n        state.loading = false;\n        state.connected = true;\n        state.address = action.payload.address;\n        state.network = action.payload.network;\n      });\n  },\n});\n\nexport const { setHasWallet } = connectWalletSlice.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\nexport const selectConnected = (state: RootState) => state.connectWallet.connected;\n\nexport const selectLoading = (state: RootState) => state.connectWallet.loading;\n\nexport const selectAddress = (state: RootState) => state.connectWallet.address;\n\nexport const selectNetwork = (state: RootState) => state.connectWallet.network;\n\nexport const selectHasWallet = (state: RootState) => state.connectWallet.hasWallet;\n\n\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\n// export const incrementIfOdd = (amount: number): AppThunk => (\n//   dispatch,\n//   getState\n// ) => {\n//   const currentValue = selectCount(getState());\n//   if (currentValue % 2 === 1) {\n//     dispatch(incrementByAmount(amount));\n//   }\n// };\n\nexport default connectWalletSlice.reducer;\n","import React from 'react';\n\nimport { useAppSelector, useAppDispatch } from '../../app/hooks';\nimport {\n  selectAddress,\n  selectConnected,\n  selectLoading,\n  selectNetwork,\n  connectWalletAsync,\n  selectHasWallet,\n  hasWalletAsync\n} from './connectWalletSlice';\n\nexport function ConnectWallet() {\n  const loading = useAppSelector(selectLoading);\n  const connected = useAppSelector(selectConnected);\n  const address = useAppSelector(selectAddress);\n  const network = useAppSelector(selectNetwork);\n  const hasWallet = useAppSelector(selectHasWallet);\n  const dispatch = useAppDispatch();\n\n  return (\n    <div>\n      {\n        !hasWallet ? <div>Please install a wallet like <a target=\"_blank\" rel=\"noreferrer\" href=\"https://metamask.io\">MetaMask</a> and try again.</div> :\n          loading ? \"Loading...\" :\n            connected ?\n              <><span>{network}</span> <span>{address}</span> <a target=\"_blank\" rel=\"noreferrer\" href={`https://rinkeby.etherscan.io/address/${address}`}>Etherescan</a></> :\n              <button onClick={() => dispatch(connectWalletAsync())}>Connect Wallet</button>\n      }\n    </div>\n  );\n}\n","import { NftMint } from \"./nftFaucetSlice\";\r\nimport Web3 from \"web3\";\r\nimport nftFaucetAbi from \"./NFtFaucetAbi.json\";\r\nimport { AbiItem } from \"web3-utils\";\r\n\r\ndeclare global {\r\n  interface Window { ethereum: any; }\r\n}\r\n\r\nexport const nftFaucetAddress = \"0x5a3b5aD2397A92a6Ff417489A24B16edEc7bC418\";\r\n\r\nlet nftFaucetContract: any;\r\nconst getNftFaucetContract = async () => {\r\n  const web3 = new Web3(window.ethereum);\r\n  if (!nftFaucetContract) {\r\n    nftFaucetContract = await new web3.eth.Contract(nftFaucetAbi as AbiItem[], nftFaucetAddress);\r\n  }\r\n  return nftFaucetContract;\r\n}\r\n\r\nexport const listenForMints = async (callback: (mint: NftMint) => void) => {\r\n  const nftFaucetContract = await getNftFaucetContract();\r\n  nftFaucetContract.events.Transfer({ filter: { to: window.ethereum.selectedAddress } }, async function (error: any, event: any) {\r\n    console.log(\"Transfer\", event);\r\n    if (error) {\r\n      console.error(\"listenForMints\", error);\r\n      // callback(error);\r\n    }\r\n    const tokenId = event.returnValues[2];\r\n    const tokenUri = await nftFaucetContract.methods.tokenURI(tokenId).call();\r\n    callback({\r\n      tokenId,\r\n      tokenUri\r\n    });\r\n  });\r\n};\r\n\r\nexport const mint = async () => {\r\n  const nftFaucetContract = await getNftFaucetContract();\r\n\r\n  const transactionParameters = {\r\n    to: nftFaucetAddress, // Required except during contract publications.\r\n    from: window.ethereum.selectedAddress, // must match user's active address.\r\n    data: nftFaucetContract.methods.mint().encodeABI()//make call to NFT smart contract \r\n  };\r\n\r\n  const tx = await window.ethereum\r\n    .request({\r\n      method: 'eth_sendTransaction',\r\n      params: [transactionParameters],\r\n    });\r\n\r\n  return new Promise((resolve, reject) => {\r\n\r\n    nftFaucetContract.once(\"Transfer\", { filter: { to: window.ethereum.selectedAddress } }, function (error: any, event: any) {\r\n      console.log(\"Transfer\", event);\r\n      if (error) {\r\n        reject(error);\r\n      }\r\n      resolve(event.returnValues[2]);\r\n    });\r\n  });\r\n}\r\n\r\n","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from '../../app/store';\nimport { listenForMints, mint } from './nftFaucetAPI';\n\nexport interface NftMint {\n  tokenUri: string;\n  tokenId: number;\n}\n\nexport interface NftFaucetState {\n  mints: NftMint[];\n  pendingTx: boolean;\n  error?: string;\n}\n\nconst initialState: NftFaucetState = {\n  mints: [],\n  pendingTx: false,\n};\n\nlet alreadyListening = false;\n\nexport const mintAsync = createAsyncThunk(\n  'nftFaucet/mint',\n  async (arg, thunkAPI) => {\n    if (!alreadyListening) {\n      listenForMints(mint => {\n        thunkAPI.dispatch(mintSuccess(mint));\n      });\n      alreadyListening = true;\n    }\n    const tx = await mint();\n    // const receipt = await tx.wait();\n    // return receipt.transactionHash;\n  }\n);\n\nexport const nftFaucetSlice = createSlice({\n  name: 'nftFaucet',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    mintSuccess: (state, action: PayloadAction<NftMint>) => {\n      state.mints.push(action.payload);\n      state.pendingTx = false;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(mintAsync.pending, (state) => {\n        state.pendingTx = true;\n      })\n      .addCase(mintAsync.fulfilled, (state, action) => {\n        state.pendingTx = false;\n      })\n      .addCase(mintAsync.rejected, (state, action) => {\n        state.pendingTx = false;\n        state.error = \"There was an error with the transaction\"\n      })\n  },\n});\n\nexport const { mintSuccess } = nftFaucetSlice.actions;\n\nexport const selectPendingTx = (state: RootState) => state.nftFaucet?.pendingTx;\nexport const selectMints = (state: RootState) => state.nftFaucet?.mints;\n\n\nexport default nftFaucetSlice.reducer;\n","import React from 'react';\n\nimport { useAppSelector, useAppDispatch } from '../../app/hooks';\nimport { nftFaucetAddress } from './nftFaucetAPI';\nimport { mintAsync, selectMints, selectPendingTx } from './nftFaucetSlice';\nimport styles from './NftFaucet.module.css';\n\nexport function NftFaucet() {\n  const pendingTx = useAppSelector(selectPendingTx);\n  const mints = useAppSelector(selectMints);\n  const dispatch = useAppDispatch();\n\n  return (\n    <div>\n      <h2>NFT Faucet</h2>\n      <div>Rinkeby NFT Faucet Contract: {nftFaucetAddress} <a target=\"_blank\" rel=\"noreferrer\" href={`https://rinkeby.etherscan.io/address/${nftFaucetAddress}`}>Etherescan</a></div>\n      {\n        pendingTx ?\n          \"Pending Transaction...\" :\n\n          <button onClick={() => {\n            dispatch(mintAsync());\n          }}>Mint</button>\n      }\n      {mints?.length > 0 ?\n        <>\n          <h3>Recent mints:</h3>\n          <div className={styles.mintUl}>\n            {mints?.map(mint =>\n              <div className={styles.mintLi} key={mint.tokenId}>\n                <img className={styles.mintImg} src={mint.tokenUri} alt={`${mint.tokenId}`} />\n                Token ID: {mint.tokenId}\n              </div>)}\n          </div>\n        </> : null}\n      <p>Check your Rinkeby NFTs in <a target=\"_blank\" rel=\"noreferrer\" href=\"https://testnets.opensea.io/account\">Rinkeby OpenSea</a></p>\n    </div>\n  );\n}\n","// import { ethers } from \"ethers\";\r\n// import { provider, signer } from \"../connectWallet/connectWalletAPI\";\r\nimport Web3 from \"web3\";\r\nimport trashCanAbi from \"./trashCanAbi.json\";\r\nimport erc721Abi from \"./erc721Abi.json\";\r\nimport { AbiItem } from \"web3-utils\";\r\n\r\ndeclare global {\r\n  interface Window { ethereum: any; }\r\n}\r\n\r\nexport interface NftDump {\r\n  contractAddress: string,\r\n  tokenId: number;\r\n}\r\n\r\nexport const trashCanAddress = \"0x370Eff7d2Ac0ACf3E7713Ec8beC8079e825EB0d4\";\r\n\r\nlet trashCanContract: any;\r\nconst getTrashCanContract = async () => {\r\n  const web3 = new Web3(window.ethereum);\r\n  if (!trashCanContract) {\r\n    trashCanContract = await new web3.eth.Contract(trashCanAbi as AbiItem[], trashCanAddress);\r\n  }\r\n  return trashCanContract;\r\n}\r\n\r\nconst getErc721AbiContract = async (contractAddress: string) => {\r\n  const web3 = new Web3(window.ethereum);\r\n  return await new web3.eth.Contract(erc721Abi as AbiItem[], contractAddress);\r\n}\r\n\r\n\r\nexport const listenForTransfers = async (contractAddress: string, callback: (dump: NftDump) => void) => {\r\n  const nftContract = await getErc721AbiContract(contractAddress);\r\n  nftContract.events.Transfer({ filter: { from: window.ethereum.selectedAddress, to: trashCanAddress } }, async function (error: any, event: any) {\r\n    console.log(\"Transfer\", event);\r\n    if (error) {\r\n      console.error(\"listenForTransfers\", error);\r\n      // callback(error);\r\n    }\r\n    const tokenId = event.returnValues[2];\r\n    callback({\r\n      contractAddress,\r\n      tokenId,\r\n    });\r\n  });\r\n};\r\n\r\nexport const safeTransferFrom = async (contractAddress: string, tokenId: number) => {\r\n  const nftContract = await getErc721AbiContract(contractAddress);\r\n  return await nftContract.methods.safeTransferFrom(window.ethereum.selectedAddress, trashCanAddress, tokenId).send({ from: window.ethereum.selectedAddress }, (error: any, tx: string) => {\r\n    if (error) {\r\n      console.error(\"safeTransferFrom\", error);\r\n    }\r\n    console.log(\"safeTransferFrom\", tx)\r\n  });\r\n}\r\n\r\n","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from '../../app/store';\nimport { listenForTransfers, safeTransferFrom } from './trashCanAPI';\n\nexport interface TrashCanState {\n  pendingTx: boolean;\n}\n\nconst initialState: TrashCanState = {\n  pendingTx: false,\n};\n\nlet alreadyListening = false;\n\nexport const safeTransferFromAsync = createAsyncThunk(\n  'trashCan/safeTransferFrom',\n  async (arg: {contractAddress: string, tokenId: string}, thunkAPI) => {\n    if (!alreadyListening) {\n      listenForTransfers(arg.contractAddress, () => {\n        thunkAPI.dispatch(transferSuccess());\n      });\n      alreadyListening = true;\n    }\n    const tx = await safeTransferFrom(arg.contractAddress, +arg.tokenId);\n    // const receipt = await tx.wait();\n    // return receipt.transactionHash;\n  }\n);\n\nexport const trashCanSlice = createSlice({\n  name: 'trashCan',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    transferSuccess: (state, action: PayloadAction<void>) => {\n      state.pendingTx = false;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(safeTransferFromAsync.pending, (state) => {\n        state.pendingTx = true;\n      })\n      .addCase(safeTransferFromAsync.fulfilled, (state, action) => {\n        state.pendingTx = false;\n      })\n  },\n});\n\nexport const { transferSuccess } = trashCanSlice.actions;\n\nexport const selectPendingTx = (state: RootState) => state.trashCan?.pendingTx;\n\nexport default trashCanSlice.reducer;\n","import React, { useState } from 'react';\n\nimport { useAppSelector, useAppDispatch } from '../../app/hooks';\nimport { nftFaucetAddress } from '../NftFaucet/nftFaucetAPI';\nimport { trashCanAddress } from './trashCanAPI';\nimport { safeTransferFromAsync, selectPendingTx } from './trashCanSlice';\n\nexport function TrashCan() {\n  const pendingTx = useAppSelector(selectPendingTx);\n  const dispatch = useAppDispatch();\n  const [contractAddress, setContractAddress] = useState(nftFaucetAddress);\n  const handleInputContractAddress = (event: any) => {\n    setContractAddress(event.target.value.trim());\n  };\n  const [tokenId, setTokenId] = useState(\"\");\n  const handleInputTokenId = (event: any) => {\n    setTokenId(event.target.value.trim());\n  };\n\n  return (\n    <div>\n      <h2>Trash Can</h2>\n      <div>Rinkeby Trash Can Contract: {trashCanAddress} <a target=\"_blank\" rel=\"noreferrer\" href={`https://rinkeby.etherscan.io/address/${trashCanAddress}`}>Etherescan</a></div>\n      {\n        pendingTx ?\n          \"Pending Transaction...\" :\n          <>\n            Contract address<input onChange={handleInputContractAddress} /><br />\n            Token ID <input onChange={handleInputTokenId} /><br />\n            <button onClick={() => {\n              dispatch(safeTransferFromAsync({ contractAddress, tokenId }));\n            }}>Dump</button>\n          </>\n      }\n    </div>\n  );\n}\n","import React from 'react';\n// import logo from './logo.svg';\n// import { Counter } from './features/counter/Counter';\nimport { ConnectWallet } from './features/connectWallet/ConnectWallet';\nimport './App.css';\n// import { useAppDispatch, useAppSelector } from './app/hooks';\nimport { NftFaucet } from './features/NftFaucet/NftFaucet';\nimport { useAppSelector } from './app/hooks';\nimport { selectConnected } from './features/connectWallet/connectWalletSlice';\nimport { TrashCan } from './features/TrashCan/TrashCan';\nimport { version } from '../package.json';\n\nfunction App() {\n  // const dispatch = useAppDispatch();\n  const connected = useAppSelector(selectConnected);\n\n  return (\n    <div className=\"App\">\n      TrashDAO\n      <ConnectWallet></ConnectWallet>\n      {connected ? <NftFaucet></NftFaucet> : null}\n      {connected ? <TrashCan></TrashCan> : null}\n      <div className=\"version\">{version}</div>\n    </div>\n  );\n}\n\nexport default App;\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\nimport connectWalletReducer, { hasWalletAsync } from '../features/connectWallet/connectWalletSlice';\nimport nftFaucetReducer from '../features/NftFaucet/nftFaucetSlice';\nimport trashCanReducer from '../features/TrashCan/trashCanSlice';\n\nexport const store = configureStore({\n  reducer: {\n    connectWallet: connectWalletReducer,\n    nftFaucet: nftFaucetReducer,\n    trashCan: trashCanReducer,\n  },\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n\nstore.dispatch(hasWalletAsync());\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"row\":\"NftFaucet_row__3sXJ3\",\"mintImg\":\"NftFaucet_mintImg__27eiB\",\"mintLi\":\"NftFaucet_mintLi__ldui-\",\"mintUl\":\"NftFaucet_mintUl__1eENz\"};"],"sourceRoot":""}