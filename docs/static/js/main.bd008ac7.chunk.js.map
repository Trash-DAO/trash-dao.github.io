{"version":3,"sources":["app/hooks.ts","features/connectWallet/connectWalletAPI.ts","features/connectWallet/connectWalletSlice.ts","features/connectWallet/ConnectWallet.tsx","features/NftFaucet/nftFaucetAPI.ts","features/NftFaucet/nftFaucetSlice.ts","features/NftFaucet/NftFaucet.tsx","features/TrashCan/trashCanAPI.ts","features/TrashCan/trashCanSlice.ts","features/TrashCan/TrashCan.tsx","App.tsx","app/store.ts","serviceWorker.ts","index.tsx"],"names":["useAppDispatch","useDispatch","useAppSelector","useSelector","provider","ethers","providers","Web3Provider","window","ethereum","signer","getSigner","connectWallet","a","enable","getAddress","getNetwork","address","network","networkVersion","isWalletConnectedAsync","createAsyncThunk","Promise","resolve","isConnected","response","connectWalletAsync","connectWalletSlice","createSlice","name","initialState","connected","loading","reducers","extraReducers","builder","addCase","pending","state","fulfilled","action","payload","selectConnected","selectLoading","selectAddress","selectNetwork","ConnectWallet","dispatch","target","rel","href","onClick","nftFaucetContract","nftFaucetAddress","getNftFaucetContract","Contract","nftFaucetAbi","listenForMints","callback","on","from","to","tokenId","event","console","log","tokenUri","mint","nftFaucetWithSigner","connect","alreadyListening","mintAsync","arg","thunkAPI","mintSuccess","tx","wait","receipt","transactionHash","nftFaucetSlice","mints","pendingTx","push","actions","selectPendingTx","nftFaucet","selectMints","NftFaucet","length","map","src","alt","trashCanAddress","nftAbi","listenForTransfers","contractAddress","safeTransferFrom","nftContract","nftWithSigner","myAddress","safeTransferFromAsync","transferSuccess","trashCanSlice","trashCan","TrashCan","useState","setContractAddress","setTokenId","onChange","value","trim","App","className","version","store","configureStore","reducer","connectWalletReducer","nftFaucetReducer","trashCanReducer","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.bd008ac7.chunk.js","sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { ethers } from \"ethers\";\r\n\r\ndeclare global {\r\n  interface Window { ethereum: any; }\r\n}\r\n\r\nexport const provider = new ethers.providers.Web3Provider(window.ethereum);\r\nexport const signer = provider?.getSigner();\r\n\r\nexport const hasWallet = () => {\r\n  return Promise.resolve(window.ethereum);\r\n}\r\n\r\nexport const isWalletConnected = () => {\r\n  return Promise.resolve(window.ethereum.isConnected());\r\n}\r\n\r\nexport const connectWallet = async () => {\r\n  await window.ethereum.enable();\r\n  return {\r\n    address: await signer.getAddress(),\r\n    network: getNetwork()\r\n  }\r\n}\r\n\r\nexport const getNetwork = () => {\r\n  if (window.ethereum.networkVersion === \"4\") {\r\n    return \"Rinkeby\";\r\n  } else {\r\n    return \"\";\r\n  }\r\n}\r\n","import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport { RootState } from '../../app/store';\nimport { isWalletConnected, connectWallet } from './connectWalletAPI';\n\nexport interface ConnectWalletState {\n  connected: boolean;\n  loading: boolean;\n  address?: string;\n  network?: string;\n}\n\nconst initialState: ConnectWalletState = {\n  connected: false,\n  loading: false,\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\nexport const isWalletConnectedAsync = createAsyncThunk(\n  'connectWallet/isWalletConnected',\n  async () => {\n    const response = await isWalletConnected();\n    // The value we return becomes the `fulfilled` action payload\n    return response;\n  }\n);\n\nexport const connectWalletAsync = createAsyncThunk(\n  'connectWallet/connectWallet',\n  async () => {\n    const response = await connectWallet();\n    // The value we return becomes the `fulfilled` action payload\n    return response;\n  }\n);\n\n\nexport const connectWalletSlice = createSlice({\n  name: 'connectWallet',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    // startLoading: (state) => {\n    //   // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n    //   // doesn't actually mutate the state because it uses the Immer library,\n    //   // which detects changes to a \"draft state\" and produces a brand new\n    //   // immutable state based off those changes\n    //   state.loading = true;\n    // },\n    // stopLoading: (state) => {\n    //   state.loading = false;\n    // },\n    // // Use the PayloadAction type to declare the contents of `action.payload`\n    // incrementByAmount: (state, action: PayloadAction<number>) => {\n    //   state.value += action.payload;\n    // },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(isWalletConnectedAsync.pending, (state) => {\n        state.loading = true;\n      })\n      .addCase(isWalletConnectedAsync.fulfilled, (state, action) => {\n        state.loading = false;\n        state.connected = action.payload;\n      })\n      .addCase(connectWalletAsync.pending, (state) => {\n        state.loading = true;\n      })\n      .addCase(connectWalletAsync.fulfilled, (state, action) => {\n        state.loading = false;\n        state.connected = true;\n        state.address = action.payload.address;\n        state.network = action.payload.network;\n      });\n  },\n});\n\n// export const {  } = connectWalletSlice.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\nexport const selectConnected = (state: RootState) => state.connectWallet.connected;\n\nexport const selectLoading = (state: RootState) => state.connectWallet.loading;\n\nexport const selectAddress = (state: RootState) => state.connectWallet.address;\n\nexport const selectNetwork = (state: RootState) => state.connectWallet.network;\n\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\n// export const incrementIfOdd = (amount: number): AppThunk => (\n//   dispatch,\n//   getState\n// ) => {\n//   const currentValue = selectCount(getState());\n//   if (currentValue % 2 === 1) {\n//     dispatch(incrementByAmount(amount));\n//   }\n// };\n\nexport default connectWalletSlice.reducer;\n","import React from 'react';\n\nimport { useAppSelector, useAppDispatch } from '../../app/hooks';\nimport {\n  selectAddress,\n  selectConnected,\n  selectLoading,\n  selectNetwork,\n  connectWalletAsync\n} from './connectWalletSlice';\n\nexport function ConnectWallet() {\n  const loading = useAppSelector(selectLoading);\n  const connected = useAppSelector(selectConnected);\n  const address = useAppSelector(selectAddress);\n  const network = useAppSelector(selectNetwork);\n  const dispatch = useAppDispatch();\n\n  return (\n    <div>\n      {loading ?\n        \"Loading...\" :\n        connected ?\n          <><span>{network}</span> <span>{address}</span> <a target=\"_blank\" rel=\"noreferrer\" href={`https://rinkeby.etherscan.io/address/${address}`}>Etherescan</a></>\n          :\n          <button onClick={() => dispatch(connectWalletAsync())}>Connect Wallet</button>\n      }\n    </div>\n  );\n}\n","import { ethers } from \"ethers\";\r\nimport { provider, signer } from \"../connectWallet/connectWalletAPI\";\r\nimport { NftMint } from \"./nftFaucetSlice\";\r\n\r\ndeclare global {\r\n  interface Window { ethereum: any; }\r\n}\r\n\r\nexport const nftFaucetAddress = \"0x5a3b5aD2397A92a6Ff417489A24B16edEc7bC418\";\r\n\r\nlet nftFaucetContract: ethers.Contract;\r\nconst getNftFaucetContract = () => {\r\n  if (!nftFaucetContract) {\r\n    nftFaucetContract = new ethers.Contract(nftFaucetAddress, nftFaucetAbi, provider);\r\n  }\r\n  return nftFaucetContract;\r\n}\r\n\r\nconst nftFaucetAbi = [\r\n  \"function mint() returns (uint)\",\r\n  \"function tokenUri(uint tokenId) view returns (string)\",\r\n  \"event Transfer(address indexed from, address indexed to, uint tokenId)\"\r\n];\r\n\r\nexport const fetchTokenUri = (tokenId: number) => {\r\n  const nftFaucetContract = getNftFaucetContract();\r\n  return nftFaucetContract.tokenUri(tokenId);\r\n}\r\n\r\nexport const listenForMints = async (callback: (mint: NftMint) => void) => {\r\n  const nftFaucetContract = getNftFaucetContract();\r\n  // const myAddress = await signer.getAddress();\r\n  // console.log(\"myAddress\", myAddress)\r\n  // const filter = nftFaucetContract.filters.Transfer(null, myAddress)\r\n  // console.log(\"filter\", filter)\r\n  // nftFaucetContract.on(filter, async (from, to, tokenId, event) => {\r\n  //   console.log(\"calling\", myAddress)\r\n  //   const tokenUri = await fetchTokenUri(tokenId);\r\n  //   console.log(\"tokenUri\", tokenUri)\r\n  //   callback({\r\n  //     tokenId,\r\n  //     tokenUri,\r\n  //   } as NftMint);\r\n  // });\r\n  nftFaucetContract.on(\"Transfer\", (from, to, tokenId, event) => {\r\n    console.log(`${from} sent ${tokenId} to ${to}`);\r\n    callback({\r\n      tokenId,\r\n      tokenUri: \"\",\r\n    } as NftMint);\r\n});\r\n  console.log(\"done listening\")\r\n};\r\n\r\nexport const mint = async () => {\r\n  const nftFaucetContract = getNftFaucetContract();\r\n  const nftFaucetWithSigner = nftFaucetContract.connect(signer);\r\n  return await nftFaucetWithSigner.mint();\r\n  // const tx = await nftFaucetWithSigner.mint();\r\n  // return tx.wait().then((receipt: any) => receipt.transactionHash);\r\n}\r\n\r\n","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from '../../app/store';\nimport { listenForMints, mint } from './nftFaucetAPI';\n\nexport interface NftMint {\n  tokenUri: string;\n  tokenId: number;\n}\n\nexport interface NftFaucetState {\n  mints: NftMint[];\n  pendingTx: boolean;\n}\n\nconst initialState: NftFaucetState = {\n  mints: [],\n  pendingTx: false,\n};\n\nlet alreadyListening = false;\n\nexport const mintAsync = createAsyncThunk(\n  'nftFaucet/mint',\n  async (arg, thunkAPI) => {\n    if (!alreadyListening) {\n      listenForMints(mint => {\n        thunkAPI.dispatch(mintSuccess(mint));\n      });\n      alreadyListening = true;\n    }\n    const tx = await mint();\n    const receipt = await tx.wait();\n    return receipt.transactionHash;\n  }\n);\n\nexport const nftFaucetSlice = createSlice({\n  name: 'nftFaucet',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    mintSuccess: (state, action: PayloadAction<NftMint>) => {\n      state.mints.push(action.payload);\n      state.pendingTx = false;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(mintAsync.pending, (state) => {\n        state.pendingTx = true;\n      })\n      .addCase(mintAsync.fulfilled, (state, action) => {\n        state.pendingTx = false;\n      })\n  },\n});\n\nexport const { mintSuccess } = nftFaucetSlice.actions;\n\nexport const selectPendingTx = (state: RootState) => state.nftFaucet?.pendingTx;\nexport const selectMints = (state: RootState) => state.nftFaucet?.mints;\n\n\nexport default nftFaucetSlice.reducer;\n","import React from 'react';\n\nimport { useAppSelector, useAppDispatch } from '../../app/hooks';\nimport { nftFaucetAddress } from './nftFaucetAPI';\nimport { mintAsync, selectMints, selectPendingTx } from './nftFaucetSlice';\n\nexport function NftFaucet() {\n  const pendingTx = useAppSelector(selectPendingTx);\n  const mints = useAppSelector(selectMints);\n  const dispatch = useAppDispatch();\n\n  return (\n    <div>\n      <h2>NFT Faucet</h2>\n      <div>Rinkeby NFT Faucet Contract: {nftFaucetAddress} <a target=\"_blank\" rel=\"noreferrer\" href={`https://rinkeby.etherscan.io/address/${nftFaucetAddress}`}>Etherescan</a></div>\n      {\n        pendingTx ?\n          \"Pending Transaction...\" :\n\n          <button onClick={() => {\n            dispatch(mintAsync());\n          }}>Mint</button>\n      }\n      {mints?.length > 0 ?\n        <>\n          <h3>Recent mints:</h3>\n          <ul>\n            {mints?.map(mint =>\n              <li>\n                <img src={mint.tokenUri} alt={`${mint.tokenId}`} />\n                Token ID: {mint.tokenId}\n              </li>)}\n          </ul>\n        </> : null}\n      <p>Check your Rinkeby NFTs in <a target=\"_blank\" rel=\"noreferrer\" href=\"https://testnets.opensea.io/account\">Rinkeby OpenSea</a></p>\n    </div>\n  );\n}\n","import { ethers } from \"ethers\";\r\nimport { provider, signer } from \"../connectWallet/connectWalletAPI\";\r\n\r\ndeclare global {\r\n  interface Window { ethereum: any; }\r\n}\r\n\r\nexport const trashCanAddress = \"0x370Eff7d2Ac0ACf3E7713Ec8beC8079e825EB0d4\";\r\n\r\nconst nftAbi = [\r\n  \"function safeTransferFrom(address _from, address _to, uint256 _tokenId)\",\r\n  \"event Transfer(address indexed from, address indexed to, uint tokenId)\"\r\n];\r\n\r\nexport const listenForTransfers = async (contractAddress: string, callback: () => void) => {\r\n  const nftContract = new ethers.Contract(contractAddress, nftAbi, provider);\r\n  // const myAddress = await signer.getAddress();\r\n  // console.log(\"myAddress\", myAddress)\r\n  // const filter = nftFaucetContract.filters.Transfer(null, myAddress)\r\n  // console.log(\"filter\", filter)\r\n  // nftFaucetContract.on(filter, async (from, to, tokenId, event) => {\r\n  //   console.log(\"calling\", myAddress)\r\n  //   const tokenUri = await fetchTokenUri(tokenId);\r\n  //   console.log(\"tokenUri\", tokenUri)\r\n  //   callback({\r\n  //     tokenId,\r\n  //     tokenUri,\r\n  //   } as NftMint);\r\n  // });\r\n  nftContract.on(\"Transfer\", (from, to, tokenId, event) => {\r\n    console.log(`${from} sent ${tokenId} to ${to}`);\r\n    callback();\r\n});\r\n  console.log(\"done listening\")\r\n};\r\n\r\nexport const safeTransferFrom = async (contractAddress: string, tokenId: number) => {\r\n  const nftContract = new ethers.Contract(contractAddress, nftAbi, provider);\r\n  const nftWithSigner = nftContract.connect(signer);\r\n  const myAddress = await signer.getAddress();\r\n  return await nftWithSigner.safeTransferFrom(myAddress, trashCanAddress, tokenId);\r\n}\r\n\r\n","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from '../../app/store';\nimport { listenForTransfers, safeTransferFrom } from './trashCanAPI';\n\nexport interface TrashCanState {\n  pendingTx: boolean;\n}\n\nconst initialState: TrashCanState = {\n  pendingTx: false,\n};\n\nlet alreadyListening = false;\n\nexport const safeTransferFromAsync = createAsyncThunk(\n  'trashCan/safeTransferFrom',\n  async (arg: {contractAddress: string, tokenId: string}, thunkAPI) => {\n    if (!alreadyListening) {\n      listenForTransfers(arg.contractAddress, () => {\n        thunkAPI.dispatch(transferSuccess());\n      });\n      alreadyListening = true;\n    }\n    const tx = await safeTransferFrom(arg.contractAddress, +arg.tokenId);\n    const receipt = await tx.wait();\n    return receipt.transactionHash;\n  }\n);\n\nexport const trashCanSlice = createSlice({\n  name: 'trashCan',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    transferSuccess: (state, action: PayloadAction<void>) => {\n      state.pendingTx = false;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(safeTransferFromAsync.pending, (state) => {\n        state.pendingTx = true;\n      })\n      .addCase(safeTransferFromAsync.fulfilled, (state, action) => {\n        state.pendingTx = false;\n      })\n  },\n});\n\nexport const { transferSuccess } = trashCanSlice.actions;\n\nexport const selectPendingTx = (state: RootState) => state.trashCan?.pendingTx;\n\nexport default trashCanSlice.reducer;\n","import React, { useState } from 'react';\n\nimport { useAppSelector, useAppDispatch } from '../../app/hooks';\nimport { nftFaucetAddress } from '../NftFaucet/nftFaucetAPI';\nimport { trashCanAddress } from './trashCanAPI';\nimport { safeTransferFromAsync, selectPendingTx } from './trashCanSlice';\n\nexport function TrashCan() {\n  const pendingTx = useAppSelector(selectPendingTx);\n  const dispatch = useAppDispatch();\n  const [contractAddress, setContractAddress] = useState(nftFaucetAddress);\n  const handleInputContractAddress = (event: any) => {\n    setContractAddress(event.target.value.trim());\n  };\n  const [tokenId, setTokenId] = useState(\"\");\n  const handleInputTokenId = (event: any) => {\n    setTokenId(event.target.value.trim());\n  };\n\n  return (\n    <div>\n      <h2>Trash Can</h2>\n      <div>Rinkeby Trash Can Contract: {trashCanAddress} <a target=\"_blank\" rel=\"noreferrer\" href={`https://rinkeby.etherscan.io/address/${trashCanAddress}`}>Etherescan</a></div>\n      {\n        pendingTx ?\n          \"Pending Transaction...\" :\n          <>\n            Contract address<input onChange={handleInputContractAddress} /><br />\n            Token ID <input onChange={handleInputTokenId} /><br />\n            <button onClick={() => {\n              dispatch(safeTransferFromAsync({ contractAddress, tokenId }));\n            }}>Dump</button>\n          </>\n      }\n    </div>\n  );\n}\n","import React from 'react';\n// import logo from './logo.svg';\n// import { Counter } from './features/counter/Counter';\nimport { ConnectWallet } from './features/connectWallet/ConnectWallet';\nimport './App.css';\n// import { useAppDispatch, useAppSelector } from './app/hooks';\nimport { NftFaucet } from './features/NftFaucet/NftFaucet';\nimport { useAppSelector } from './app/hooks';\nimport { selectConnected } from './features/connectWallet/connectWalletSlice';\nimport { TrashCan } from './features/TrashCan/TrashCan';\nimport { version } from '../package.json';\n\nfunction App() {\n  // const dispatch = useAppDispatch();\n  const connected = useAppSelector(selectConnected);\n\n  return (\n    <div className=\"App\">\n      TrashDAO\n      <ConnectWallet></ConnectWallet>\n      {connected ? <NftFaucet></NftFaucet> : null}\n      {connected ? <TrashCan></TrashCan> : null}\n      <div className=\"version\">{version}</div>\n    </div>\n  );\n}\n\nexport default App;\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\nimport connectWalletReducer from '../features/connectWallet/connectWalletSlice';\nimport nftFaucetReducer from '../features/NftFaucet/nftFaucetSlice';\nimport trashCanReducer from '../features/TrashCan/trashCanSlice';\n\nexport const store = configureStore({\n  reducer: {\n    connectWallet: connectWalletReducer,\n    nftFaucet: nftFaucetReducer,\n    trashCan: trashCanReducer,\n  },\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}